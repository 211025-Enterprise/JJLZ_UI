{"ast":null,"code":"'use strict';\n\nvar isArray = Array.isArray;\nvar ab = ArrayBuffer;\nvar dv = DataView;\n\nfunction isTypedArray(a) {\n  return ab.isView(a) && !(a instanceof dv);\n}\n\nexports.isTypedArray = isTypedArray;\n\nfunction isArrayOrTypedArray(a) {\n  return isArray(a) || isTypedArray(a);\n}\n\nexports.isArrayOrTypedArray = isArrayOrTypedArray;\n/*\r\n * Test whether an input object is 1D.\r\n *\r\n * Assumes we already know the object is an array.\r\n *\r\n * Looks only at the first element, if the dimensionality is\r\n * not consistent we won't figure that out here.\r\n */\n\nfunction isArray1D(a) {\n  return !isArrayOrTypedArray(a[0]);\n}\n\nexports.isArray1D = isArray1D;\n/*\r\n * Ensures an array has the right amount of storage space. If it doesn't\r\n * exist, it creates an array. If it does exist, it returns it if too\r\n * short or truncates it in-place.\r\n *\r\n * The goal is to just reuse memory to avoid a bit of excessive garbage\r\n * collection.\r\n */\n\nexports.ensureArray = function (out, n) {\n  // TODO: typed array support here? This is only used in\n  // traces/carpet/compute_control_points\n  if (!isArray(out)) out = []; // If too long, truncate. (If too short, it will grow\n  // automatically so we don't care about that case)\n\n  out.length = n;\n  return out;\n};\n/*\r\n * TypedArray-compatible concatenation of n arrays\r\n * if all arrays are the same type it will preserve that type,\r\n * otherwise it falls back on Array.\r\n * Also tries to avoid copying, in case one array has zero length\r\n * But never mutates an existing array\r\n */\n\n\nexports.concat = function () {\n  var args = [];\n  var allArray = true;\n  var totalLen = 0;\n\n  var _constructor, arg0, i, argi, posi, leni, out, j;\n\n  for (i = 0; i < arguments.length; i++) {\n    argi = arguments[i];\n    leni = argi.length;\n\n    if (leni) {\n      if (arg0) args.push(argi);else {\n        arg0 = argi;\n        posi = leni;\n      }\n\n      if (isArray(argi)) {\n        _constructor = false;\n      } else {\n        allArray = false;\n\n        if (!totalLen) {\n          _constructor = argi.constructor;\n        } else if (_constructor !== argi.constructor) {\n          // TODO: in principle we could upgrade here,\n          // ie keep typed array but convert all to Float64Array?\n          _constructor = false;\n        }\n      }\n\n      totalLen += leni;\n    }\n  }\n\n  if (!totalLen) return [];\n  if (!args.length) return arg0;\n  if (allArray) return arg0.concat.apply(arg0, args);\n\n  if (_constructor) {\n    // matching typed arrays\n    out = new _constructor(totalLen);\n    out.set(arg0);\n\n    for (i = 0; i < args.length; i++) {\n      argi = args[i];\n      out.set(argi, posi);\n      posi += argi.length;\n    }\n\n    return out;\n  } // mismatched types or Array + typed\n\n\n  out = new Array(totalLen);\n\n  for (j = 0; j < arg0.length; j++) {\n    out[j] = arg0[j];\n  }\n\n  for (i = 0; i < args.length; i++) {\n    argi = args[i];\n\n    for (j = 0; j < argi.length; j++) {\n      out[posi + j] = argi[j];\n    }\n\n    posi += j;\n  }\n\n  return out;\n};\n\nexports.maxRowLength = function (z) {\n  return _rowLength(z, Math.max, 0);\n};\n\nexports.minRowLength = function (z) {\n  return _rowLength(z, Math.min, Infinity);\n};\n\nfunction _rowLength(z, fn, len0) {\n  if (isArrayOrTypedArray(z)) {\n    if (isArrayOrTypedArray(z[0])) {\n      var len = len0;\n\n      for (var i = 0; i < z.length; i++) {\n        len = fn(len, z[i].length);\n      }\n\n      return len;\n    } else {\n      return z.length;\n    }\n  }\n\n  return 0;\n}","map":null,"metadata":{},"sourceType":"script"}