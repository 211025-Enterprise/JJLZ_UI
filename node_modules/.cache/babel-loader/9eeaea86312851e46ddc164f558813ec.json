{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar loggers = require('./loggers');\n\nvar identity = require('./identity');\n\nvar BADNUM = require('../constants/numerical').BADNUM; // don't trust floating point equality - fraction of bin size to call\n// \"on the line\" and ensure that they go the right way specified by\n// linelow\n\n\nvar roundingError = 1e-9;\n/**\r\n * findBin - find the bin for val - note that it can return outside the\r\n * bin range any pos. or neg. integer for linear bins, or -1 or\r\n * bins.length-1 for explicit.\r\n * bins is either an object {start,size,end} or an array length #bins+1\r\n * bins can be either increasing or decreasing but must be monotonic\r\n * for linear bins, we can just calculate. For listed bins, run a binary\r\n * search linelow (truthy) says the bin boundary should be attributed to\r\n * the lower bin rather than the default upper bin\r\n */\n\nexports.findBin = function (val, bins, linelow) {\n  if (isNumeric(bins.start)) {\n    return linelow ? Math.ceil((val - bins.start) / bins.size - roundingError) - 1 : Math.floor((val - bins.start) / bins.size + roundingError);\n  } else {\n    var n1 = 0;\n    var n2 = bins.length;\n    var c = 0;\n    var binSize = n2 > 1 ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;\n    var n, test;\n\n    if (binSize >= 0) {\n      test = linelow ? lessThan : lessOrEqual;\n    } else {\n      test = linelow ? greaterOrEqual : greaterThan;\n    }\n\n    val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1); // c is just to avoid infinite loops if there's an error\n\n    while (n1 < n2 && c++ < 100) {\n      n = Math.floor((n1 + n2) / 2);\n      if (test(bins[n], val)) n1 = n + 1;else n2 = n;\n    }\n\n    if (c > 90) loggers.log('Long binary search...');\n    return n1 - 1;\n  }\n};\n\nfunction lessThan(a, b) {\n  return a < b;\n}\n\nfunction lessOrEqual(a, b) {\n  return a <= b;\n}\n\nfunction greaterThan(a, b) {\n  return a > b;\n}\n\nfunction greaterOrEqual(a, b) {\n  return a >= b;\n}\n\nexports.sorterAsc = function (a, b) {\n  return a - b;\n};\n\nexports.sorterDes = function (a, b) {\n  return b - a;\n};\n/**\r\n * find distinct values in an array, lumping together ones that appear to\r\n * just be off by a rounding error\r\n * return the distinct values and the minimum difference between any two\r\n */\n\n\nexports.distinctVals = function (valsIn) {\n  var vals = valsIn.slice(); // otherwise we sort the original array...\n\n  vals.sort(exports.sorterAsc); // undefined listed in the end - also works on IE11\n\n  var last;\n\n  for (last = vals.length - 1; last > -1; last--) {\n    if (vals[last] !== BADNUM) break;\n  }\n\n  var minDiff = vals[last] - vals[0] || 1;\n  var errDiff = minDiff / (last || 1) / 10000;\n  var newVals = [];\n  var preV;\n\n  for (var i = 0; i <= last; i++) {\n    var v = vals[i]; // make sure values aren't just off by a rounding error\n\n    var diff = v - preV;\n\n    if (preV === undefined) {\n      newVals.push(v);\n      preV = v;\n    } else if (diff > errDiff) {\n      minDiff = Math.min(minDiff, diff);\n      newVals.push(v);\n      preV = v;\n    }\n  }\n\n  return {\n    vals: newVals,\n    minDiff: minDiff\n  };\n};\n/**\r\n * return the smallest element from (sorted) array arrayIn that's bigger than val,\r\n * or (reverse) the largest element smaller than val\r\n * used to find the best tick given the minimum (non-rounded) tick\r\n * particularly useful for date/time where things are not powers of 10\r\n * binary search is probably overkill here...\r\n */\n\n\nexports.roundUp = function (val, arrayIn, reverse) {\n  var low = 0;\n  var high = arrayIn.length - 1;\n  var mid;\n  var c = 0;\n  var dlow = reverse ? 0 : 1;\n  var dhigh = reverse ? 1 : 0;\n  var rounded = reverse ? Math.ceil : Math.floor; // c is just to avoid infinite loops if there's an error\n\n  while (low < high && c++ < 100) {\n    mid = rounded((low + high) / 2);\n    if (arrayIn[mid] <= val) low = mid + dlow;else high = mid - dhigh;\n  }\n\n  return arrayIn[low];\n};\n/**\r\n * Tweak to Array.sort(sortFn) that improves performance for pre-sorted arrays\r\n *\r\n * Note that newer browsers (such as Chrome v70+) are starting to pick up\r\n * on pre-sorted arrays which may render the following optimization unnecessary\r\n * in the future.\r\n *\r\n * Motivation: sometimes we need to sort arrays but the input is likely to\r\n * already be sorted. Browsers don't seem to pick up on pre-sorted arrays,\r\n * and in fact Chrome is actually *slower* sorting pre-sorted arrays than purely\r\n * random arrays. FF is at least faster if the array is pre-sorted, but still\r\n * not as fast as it could be.\r\n * Here's how this plays out sorting a length-1e6 array:\r\n *\r\n * Calls to Sort FN  |  Chrome bare  |  FF bare  |  Chrome tweak  |  FF tweak\r\n *                   |  v68.0 Mac    |  v61.0 Mac|                |\r\n * ------------------+---------------+-----------+----------------+------------\r\n * ordered           |  30.4e6       |  10.1e6   |  1e6           |  1e6\r\n * reversed          |  29.4e6       |  9.9e6    |  1e6 + reverse |  1e6 + reverse\r\n * random            |  ~21e6        |  ~18.7e6  |  ~21e6         |  ~18.7e6\r\n *\r\n * So this is a substantial win for pre-sorted (ordered or exactly reversed)\r\n * arrays. Including this wrapper on an unsorted array adds a penalty that will\r\n * in general be only a few calls to the sort function. The only case this\r\n * penalty will be significant is if the array is mostly sorted but there are\r\n * a few unsorted items near the end, but the penalty is still at most N calls\r\n * out of (for N=1e6) ~20N total calls\r\n *\r\n * @param {Array} array: the array, to be sorted in place\r\n * @param {function} sortFn: As in Array.sort, function(a, b) that puts\r\n *     item a before item b if the return is negative, a after b if positive,\r\n *     and no change if zero.\r\n * @return {Array}: the original array, sorted in place.\r\n */\n\n\nexports.sort = function (array, sortFn) {\n  var notOrdered = 0;\n  var notReversed = 0;\n\n  for (var i = 1; i < array.length; i++) {\n    var pairOrder = sortFn(array[i], array[i - 1]);\n    if (pairOrder < 0) notOrdered = 1;else if (pairOrder > 0) notReversed = 1;\n    if (notOrdered && notReversed) return array.sort(sortFn);\n  }\n\n  return notReversed ? array : array.reverse();\n};\n/**\r\n * find index in array 'arr' that minimizes 'fn'\r\n *\r\n * @param {array} arr : array where to search\r\n * @param {fn (optional)} fn : function to minimize,\r\n *   if not given, fn is the identity function\r\n * @return {integer}\r\n */\n\n\nexports.findIndexOfMin = function (arr, fn) {\n  fn = fn || identity;\n  var min = Infinity;\n  var ind;\n\n  for (var i = 0; i < arr.length; i++) {\n    var v = fn(arr[i]);\n\n    if (v < min) {\n      min = v;\n      ind = i;\n    }\n  }\n\n  return ind;\n};","map":null,"metadata":{},"sourceType":"script"}